from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime

# --- Root CA Schemas ---
class RootCACertificateBase(BaseModel):
    name: str = Field(..., description="CA Name/Identifier")
    certificate_pem: str = Field(..., description="PEM-encoded CA certificate chain")
    # For initial upload, private key is optional and assumed plain text
    private_key_pem: Optional[str] = Field(None, description="Plain text PEM-encoded private key (if CA will be used for signing)")
    is_issuer: bool = Field(False, description="Is this CA configured as an active issuer by the system?")

class RootCACertificateCreate(RootCACertificateBase):
    pass

class RootCACertificateRead(RootCACertificateBase):
    id: int
    # To show the actual stored field names, but still mark them as optional if they can be null
    encrypted_private_key: Optional[str] = Field(None, description="Encrypted PEM-encoded private key of the CA (if used for signing)")
    private_key_salt: Optional[str] = Field(None, description="Salt for private key encryption/decryption")
    created_at: datetime
    updated_at: datetime
    uploaded_by_id: Optional[int] = None

    class Config:
        from_attributes = True # Replaces orm_mode in Pydantic v2

class RootCACertificateUpdate(BaseModel):
    name: Optional[str] = None
    is_issuer: Optional[bool] = None
    certificate_pem: Optional[str] = None # Allow updating cert
    private_key_pem: Optional[str] = None # Allow updating key (still assumed plain text for this step)


# --- Certificate Request Schemas ---
class CertificateRequestCreate(BaseModel):
    common_name: str = Field(..., description="Requested Common Name (e.g., server.example.com)")
    # Using Dict for sans, e.g., {"dns": ["example.com", "www.example.com"], "ip": ["1.2.3.4"]}
    sans: Optional[Dict[str, List[str]]] = Field(None, description="Subject Alternative Names. Keys: 'dns', 'ip'. Values: list of strings.")


class CertificateRequestRead(BaseModel):
    id: int
    common_name: str
    sans: Optional[Dict[str, List[str]]] = None
    status: str
    rejection_reason: Optional[str] = None
    requested_by_id: int
    created_at: datetime
    updated_at: datetime
    approved_by_id: Optional[int] = None
    processed_at: Optional[datetime] = None
    # issued_certificate_id: Optional[int] = None # Can be added if direct link is needed

    class Config:
        from_attributes = True

class CertificateRequestUpdateByAdmin(BaseModel): # For approve/reject by admin
    status: str = Field(..., description="New status: 'approved' or 'rejected'")
    rejection_reason: Optional[str] = Field(None, description="Reason for rejection (required if status is 'rejected')")

class CertificateRequestUserRead(CertificateRequestRead): # Schema for user viewing their own requests
    pass


# --- Issued Certificate Schemas (Basic for now) ---
class IssuedCertificateRead(BaseModel):
    id: int
    serial_number: str
    subject_dn: str
    issuer_dn: str
    valid_from: datetime
    valid_to: datetime
    status: str
    certificate_pem: str = Field(..., description="PEM-encoded certificate, potentially including the chain")
    # encrypted_private_key: Optional[str] = Field(None, description="User's private key (if generated by system and stored)")
    # private_key_salt: Optional[str] = None
    request_id: int
    issued_by_ca_id: int
    issued_by_user_id: Optional[int] = None
    revoked_by_user_id: Optional[int] = None
    revoked_at: Optional[datetime] = None

    class Config:
        from_attributes = True
